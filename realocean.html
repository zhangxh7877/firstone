<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - 真实感海洋效果</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // 1. 场景基础设置
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 10, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 2, 0);

        // 2. 环境与光照
        const sun = new THREE.DirectionalLight(0xffffff, 2.0);
        sun.position.set(20, 30, 30);
        scene.add(sun);

        const cubeTextureLoader = new THREE.CubeTextureLoader();
        const skyboxTexture = cubeTextureLoader.load([
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg',
        ]);
        scene.background = skyboxTexture;

        // 3. GLSL 着色器代码
        const vertexShader = `
            uniform float uTime;
            
            // Gerstner Wave 参数
            uniform vec2 uWaveDirection;
            uniform float uWaveSteepness;
            uniform float uWaveLength;
            uniform float uWaveSpeed;

            varying vec3 vNormal;
            varying vec3 vViewPosition;

            // Gerstner Wave 函数
            // 不仅改变y，还改变x和z，形成更尖的波峰
            vec3 gerstnerWave(vec2 position, float steepness, float wavelength, vec2 direction) {
                float k = 2.0 * 3.14159 / wavelength;
                float c = sqrt(9.8 / k);
                float f = k * (dot(direction, position) - c * uTime * uWaveSpeed);
                
                return vec3(
                    -direction.x * (steepness / k) * cos(f),
                    steepness * sin(f),
                    -direction.y * (steepness / k) * cos(f)
                );
            }

            void main() {
                vec4 modelPosition = vec4(position, 1.0);
                
                // 叠加多层Gerstner波来创造复杂海面
                vec3 waveDisplacement = vec3(0.0);
                waveDisplacement += gerstnerWave(position.xz, uWaveSteepness, uWaveLength, uWaveDirection);
                waveDisplacement += gerstnerWave(position.xz, 0.1, 20.0, vec2(1.0, 0.5));
                waveDisplacement += gerstnerWave(position.xz, 0.05, 5.0, vec2(0.5, 0.8));

                modelPosition.xyz += waveDisplacement;
                
                // 计算扰动后的法线（简化版，非精确计算）
                vec3 tangent = normalize(vec3(1.0, dot(vec2(1.0, 0.0), waveDisplacement.xz), 0.0));
                vec3 bitangent = normalize(vec3(0.0, dot(vec2(0.0, 1.0), waveDisplacement.xz), 1.0));
                vNormal = normalize(cross(tangent, bitangent));
                
                vec4 viewPosition = modelViewMatrix * modelPosition;
                vViewPosition = viewPosition.xyz;

                gl_Position = projectionMatrix * viewPosition;
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            uniform vec3 uDeepWaterColor;
            uniform vec3 uSurfaceWaterColor;
            uniform samplerCube uSky;
            uniform vec3 uSunDirection;
            uniform vec3 uSunColor;
            
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                // 1. 计算反射向量并采样天空盒
                vec3 viewDirection = normalize(vViewPosition);
                vec3 reflectDirection = reflect(viewDirection, normalize(vNormal));
                vec3 reflectionColor = textureCube(uSky, reflectDirection).rgb;

                // 2. 计算菲涅尔效应
                float fresnel = 1.0 - abs(dot(viewDirection, normalize(vNormal)));
                fresnel = pow(fresnel, 2.0);

                // 3. 混合水体自身颜色和反射颜色
                vec3 waterBaseColor = mix(uDeepWaterColor, uSurfaceWaterColor, fresnel);
                vec3 finalColor = mix(waterBaseColor, reflectionColor, fresnel);
                
                // 4. 计算太阳高光 (Blinn-Phong)
                vec3 halfwayDir = normalize(uSunDirection - viewDirection);
                float spec = pow(max(dot(normalize(vNormal), halfwayDir), 0.0), 32.0);
                vec3 specular = uSunColor * spec * 2.0;

                // 5. 组合最终颜色
                finalColor += specular;
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // 4. 创建海洋网格
        const oceanGeometry = new THREE.PlaneGeometry(100, 100, 256, 256);
        const oceanMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uSky: { value: skyboxTexture },
                uSunDirection: { value: sun.position.clone().normalize() },
                uSunColor: { value: sun.color },
                uDeepWaterColor: { value: new THREE.Color('#000033') },
                uSurfaceWaterColor: { value: new THREE.Color('#0055aa') },
                uWaveDirection: { value: new THREE.Vector2(1, 1) },
                uWaveSteepness: { value: 0.15 },
                uWaveLength: { value: 30.0 },
                uWaveSpeed: { value: 1.0 },
            }
        });

        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        scene.add(ocean);

        // 5. GUI
        const gui = new GUI();
        gui.add(oceanMaterial.uniforms.uWaveSteepness, 'value', 0, 1, 0.01).name('波浪陡峭度');
        gui.add(oceanMaterial.uniforms.uWaveLength, 'value', 1, 100, 1).name('波长');
        gui.add(oceanMaterial.uniforms.uWaveSpeed, 'value', 0, 5, 0.1).name('波速');

        // 6. 动画循环
        const clock = new THREE.Clock();
        const animate = () => {
            const elapsedTime = clock.getElapsedTime();
            oceanMaterial.uniforms.uTime.value = elapsedTime;
            
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        };
        animate();
        
        // 7. 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>